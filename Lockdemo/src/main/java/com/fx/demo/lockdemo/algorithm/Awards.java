package com.fx.demo.lockdemo.algorithm;

public class Awards {

    /**

      假设现在商场中顾客会进行购买或退货两种操作，每次操作只能购买或退货一件商品。
     给定两个等长的整形数组 arr 和布尔型数组 op ，arr[i] 表示顾客的编号，op[i]
     表示顾客的操作，T 代表该顾客购买了一件商品，F 代表该顾客退了一件商品。例如

     现在你作为电商平台负责人，想在每一个事件到来的时候（某个用户购买或者退货的时候），
     都给购买次数最多的前 K 名用户颁奖。所以 每个事件发生后 ，你 都需要得到 得奖名单 。

     规则：
     1、若用户购买商品数为 0，但发生了退货事件，则认为该事件无效，得奖名单保持不变；
     2、若用户发生购买事件，商品数 +1，发生退货事件，商品数 -1；
     3、得奖系统分为得奖区和候选区，任何用户只要购买数 >0，一定会在两个区域中的一个；
     4、购买数最大的前 K (传入参数) 名用户进入得奖区，在最初时如果得奖区没有到达 K 个用户，那么新来的用户直接进入得奖区；
     5、购买数不足以进入得奖区的用户，进入候选区；
     6、如果候选区购买数最多的用户，已经足以进入得奖区了，该用户就会替换得奖区中购买数最少的用户( 大于 才能替换)；
        如果得奖区中购买数最少的用户有多个，就替换 最早进入 得奖区的用户；如果候选区中购买数最多的用户有多个，机会会给 最早进入 候选区的用户；
     7、候选区和得奖区是 两套时间，因用户只会在其中一个区域，所以只会有一个区域的时间；
        从 得奖区出来 进入候选区的用户，得奖区时间删除，进入候选区的时间就是当前事件的时间 ( arr[i] 和 op[i] 中的 i )；
        从 候选区出来 进入得奖区的用户，候选区时间删除，进入得奖区的时间就是当前事件的时间 ( arr[i] 和 op[i] 中的 i )；
     8、若用户购买数为 0，删除该用户。如果下次该用户又发生购买行为，产生 >0 的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记。

     */
}
